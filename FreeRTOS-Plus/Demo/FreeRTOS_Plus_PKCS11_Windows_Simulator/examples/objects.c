/*
 * FreeRTOS PKCS #11 V1.0.3
 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://aws.amazon.com/freertos
 * http://www.FreeRTOS.org
 */
/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"

/* Standard includes. */
#include "stdio.h"

/* PKCS #11 includes. */
#include "iot_pkcs11_config.h"
#include "iot_pkcs11.h"
#include "pkcs11.h"

/* This function contains standard setup code for PKCS #11. See the 
 * "management_and_rng.c" file for the demo code explaining this section
 * of cryptoki.
 */
extern void prvStart( CK_SESSION_HANDLE * pxSession, CK_SLOT_ID ** ppxSlotId );

/* This function contains standard tear down code for PKCS #11. See the 
 * "management_and_rng.c" file for the demo code explaining this section
 * of cryptoki.
 */
extern void prvEnd( CK_SESSION_HANDLE xSession, CK_SLOT_ID * pxSlotId );

/** 
 * prvObjectGeneration covers how to create a public key and private key pair
 * with Cryptoki defined attributes using C_GenerateKeyPair.
 *
 */
static void prvObjectGeneration( void );

/** 
 * prvObjectImporting covers how to import a private and public key that were 
 * not generated by the Cryptoki library.
 *
 * Note: The "sign-verify.c" demo has a dependency on the objects created
 * in this function, and will not work without first running this function.
 */
static void prvObjectImporting( void );

/**
 * This function details how to use the PKCS #11 "Object" functions to 
 * manage the objects abstracted by cryptoki. 
 *
 * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html 
 * please consult the standard for more information.
 *
 * The standard has grouped the functions presented in this demo as:
 * Object Management Functions.
 * 
 */
void vPKCS11ObjectDemo( void )
{
    configPRINTF( ( "\r\nStarting PKCS #11 Objects Demo.\r\n" ) );
    /* PKCS #11 defines objects as "An item that is stored on a token. May be 
     * data, a certificate, or a key." This demo will show how to create objects
     * that are managed by Cryptoki. */
    prvObjectGeneration();
    prvObjectImporting();
    configPRINTF( ( "\r\nFinished PKCS #11 Objects Demo.\r\n" ) );
}

static void prvObjectGeneration()
{
    configPRINTF( ( "---------Generating Objects---------\r\n" ) );

    /* Helper variables. */
    CK_RV xResult = CKR_OK;
    CK_SESSION_HANDLE hSession = CK_INVALID_HANDLE;
    CK_SLOT_ID * pxSlotId = 0;
    CK_FUNCTION_LIST_PTR pxFunctionList = NULL;
    CK_BYTE * pxDerPublicKey = NULL;
    CK_ULONG ulDerPublicKeyLength = 0;
    CK_BBOOL xTrue = CK_TRUE;

    /* Specify the mechanism to use in the key pair generation. Mechanisms are
     * previously explained in the "mechanims_and_digests.c" demo. */
    CK_MECHANISM xMechanism =
    {
        CKM_EC_KEY_PAIR_GEN, NULL_PTR, 0
    };

    /* The EC curve used in this demo will be the named EC curve prime256v1.
     * For further explanations of EC Cryptography please see the following:
     * https://en.wikipedia.org/wiki/Elliptic-curve_cryptography
     * https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography
     */
    CK_BYTE xEcParams[] = pkcs11DER_ENCODED_OID_P256; 

    /* Specify the key type to be EC. */
    CK_KEY_TYPE xKeyType = CKK_EC;

    /* Object handles are a token specific identifier for an object. They are 
     * used so the application's sessions can specify which object to interact
     * with. Non-zero values are valid, 0 is always invalid, and is defined as
     * CK_INVALID_HANDLE 
     *
     * The lifetime of the handle is not necessarily the same as the lifetime of
     * the object.
     */
    CK_OBJECT_HANDLE xPrivateKeyHandle = CK_INVALID_HANDLE;
    CK_OBJECT_HANDLE xPublicKeyHandle = CK_INVALID_HANDLE;


    /* Labels are application defined strings that are used to identify an 
     * object. It should not be NULL terminated. */
    CK_BYTE pucPublicKeyLabel[] = { pkcs11configLABEL_DEVICE_PRIVATE_KEY_FOR_TLS };
    CK_BYTE pucPrivateKeyLabel[] = { pkcs11configLABEL_DEVICE_PUBLIC_KEY_FOR_TLS };

    /* CK_ATTTRIBUTE's contain an attribute type, a value, and the length of 
     * the value. An array of CK_ATTRIBUTEs is called a template. They are used
     * for creating, searching, and manipulating for objects. The order of the 
     * template does not matter.
     *
     * In the below template we are creating a public key: 
     *      Specify the key type as EC.
     *      The key will be able to verify a message. 
     *      Specify the EC Curve.
     *      Assign a label to the object that will be created.
     */
    CK_ATTRIBUTE xPublicKeyTemplate[] =
    {
        { CKA_KEY_TYPE,  NULL /* &xKeyType */, sizeof( xKeyType )              },
        { CKA_VERIFY,    NULL /* &xTrue */,    sizeof( xTrue )                 },
        { CKA_EC_PARAMS, NULL /* xEcParams */, sizeof( xEcParams )             },
        { CKA_LABEL,     pucPublicKeyLabel,    sizeof( pucPublicKeyLabel ) - 1 }
    };

    /* Aggregate initializers must not use the address of an automatic variable. */
    /* See MSVC Compiler Warning C4221 */
    xPublicKeyTemplate[ 0 ].pValue = &xKeyType;
    xPublicKeyTemplate[ 1 ].pValue = &xTrue;
    xPublicKeyTemplate[ 2 ].pValue = &xEcParams;

    /* In the below template we are creating a private key: 
     *      The key type is EC.
     *      The key is a token object.
     *      The key will be a private key.
     *      The key will be able to sign messages. 
     *      Assign a label to the object that will be created.
     */
    CK_ATTRIBUTE xPrivateKeyTemplate[] =
    {
        { CKA_KEY_TYPE, NULL /* &xKeyType */, sizeof( xKeyType )               },
        { CKA_TOKEN,    NULL /* &xTrue */,    sizeof( xTrue )                  },
        { CKA_PRIVATE,  NULL /* &xTrue */,    sizeof( xTrue )                  },
        { CKA_SIGN,     NULL /* &xTrue */,    sizeof( xTrue )                  },
        { CKA_LABEL,    pucPrivateKeyLabel,   sizeof( pucPrivateKeyLabel ) - 1 }
    };

    /* Aggregate initializers must not use the address of an automatic variable. */
    /* See MSVC Compiler Warning C4221 */
    xPrivateKeyTemplate[ 0 ].pValue = &xKeyType;
    xPrivateKeyTemplate[ 1 ].pValue = &xTrue;
    xPrivateKeyTemplate[ 2 ].pValue = &xTrue;
    xPrivateKeyTemplate[ 3 ].pValue = &xTrue;

    prvStart( &hSession, &pxSlotId ); 

    xResult = C_GetFunctionList( &pxFunctionList );
    configASSERT( xResult == CKR_OK );

    configPRINTF( ( "Creating private key with label %s \r\n", 
                pkcs11configLABEL_DEVICE_PRIVATE_KEY_FOR_TLS ) );
    configPRINTF( ( "Creating public key with label %s \r\n", 
                pkcs11configLABEL_DEVICE_PUBLIC_KEY_FOR_TLS ) );

    xResult = pxFunctionList->C_GenerateKeyPair( hSession,
                                                 &xMechanism,
                                                 xPublicKeyTemplate,
                                                 sizeof( xPublicKeyTemplate ) / sizeof( CK_ATTRIBUTE ),
                                                 xPrivateKeyTemplate, 
                                                 sizeof( xPrivateKeyTemplate ) / sizeof( CK_ATTRIBUTE ),
                                                 &xPublicKeyHandle,
                                                 &xPrivateKeyHandle );
    configASSERT( xResult == CKR_OK );
    configPRINTF( ( "FreeRTOS_P11_Key.dat has been created in the Visual Studio" \
                " Solution directory\r\n" ) );
    configPRINTF( ( "Extracting public key bytes...\r\n" ) );

    /* Export public key as hex bytes and print the hex representation of the 
     * public key. */
    vExportPublicKey( hSession, 
            xPublicKeyHandle, 
            &pxDerPublicKey, 
            &ulDerPublicKeyLength );
    vWriteHexBytesToConsole( "Public Key in Hex Format", 
            pxDerPublicKey, 
            ulDerPublicKeyLength );
    configPRINTF( ( "---------Generating Objects---------\r\n" ) );
}
    
static void prvObjectImporting()
{
    configPRINTF( ( "---------Importing Objects---------\r\n" ) );
    configPRINTF( ( "---------Finished Importing Objects---------\r\n" ) );
}
    
